// =====================
// Crypto Widget Pro ‚Äî –µ–¥–∏–Ω—ã–π —Å—Ç–∏–ª—å –∫–æ–ª–æ–Ω–æ–∫
// =====================

// === –ö–æ–Ω—Ñ–∏–≥
const CONFIG = {
  cacheMinutes: 15,
  timeout: 10,
  maxRetries: 3,

  icons: { coin: 18, portfolio: 18 },

  fonts: {
    main: { symbol: 8, price: 8, change: 6 },
    portfolio: { symbol: 8, value: 8, percent: 6 }
  },

  colors: {
    text: new Color("#ffffff"),
    subtext: new Color("#aaaaaa"),
    portfolio: new Color("#aaaaaa"),
    up: new Color("#00ff88"),
    down: new Color("#ff5555")
  }
};

// === –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –º–æ–Ω–µ—Ç (–¥–µ—Ñ–æ–ª—Ç–Ω—ã–π –Ω–∞–±–æ—Ä)
let coins = [
  { id: "bitcoin",           symbol: "BTC",  icon: "https://s2.coinmarketcap.com/static/img/coins/64x64/1.png" },
  { id: "the-open-network",  symbol: "TON",  icon: "https://assets.coingecko.com/coins/images/17980/large/ton_symbol.png" },
  { id: "near",              symbol: "NEAR", icon: "https://s2.coinmarketcap.com/static/img/coins/64x64/6535.png" },
  { id: "solana",            symbol: "SOL",  icon: "https://s2.coinmarketcap.com/static/img/coins/64x64/5426.png" },
  { id: "ethereum",          symbol: "ETH",  icon: "https://s2.coinmarketcap.com/static/img/coins/64x64/1027.png" },
  { id: "cardano",           symbol: "ADA",  icon: "https://s2.coinmarketcap.com/static/img/coins/64x64/2010.png" }
];

// –ë—ã—Å—Ç—Ä—ã–π –¥–æ—Å—Ç—É–ø coinId ‚Üí –æ–±—ä–µ–∫—Ç –º–æ–Ω–µ—Ç—ã
const COINS_BY_ID = new Map(coins.map(c => [c.id, c]));

// === –§–°/–ø—É—Ç–∏
const fm = FileManager.local();
const basePath = fm.documentsDirectory();
const paths = {
  icons:     fm.joinPath(basePath, "crypto_icons"),
  cache:     fm.joinPath(basePath, "crypto_cache.json"),     // –∫—ç—à —Ü–µ–Ω (—Å –∫–ª—é—á–æ–º ids)
  search:    fm.joinPath(basePath, "search_cache.json"),     // –∫—ç—à –ø–æ–∏—Å–∫–∞
  settings:  fm.joinPath(basePath, "crypto_settings.json"),
  portfolio: fm.joinPath(basePath, "crypto_portfolio.json"),
  alerts:    fm.joinPath(basePath, "crypto_alerts.json")
};
if (!fm.fileExists(paths.icons)) fm.createDirectory(paths.icons);

// === –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
const DEFAULT_SETTINGS = {
  selectedCoins: coins.slice(0, 3),
  extraCoins: coins.slice(3, 6),
  rightMode: 'extra', // 'extra' | 'portfolio'
  showChange: true,
  notifications: { enabled: true, priceChange: 10, portfolioChange: 5 }
};

// =====================
// –£—Ç–∏–ª–∏—Ç—ã
// =====================

// –ù–∞—Å—Ç—Ä–æ–π–∫–∏
function loadSettings() {
  if (fm.fileExists(paths.settings)) {
    try {
      const settings = JSON.parse(fm.readString(paths.settings));
      return { ...DEFAULT_SETTINGS, ...settings };
    } catch (e) {
      console.log(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫: ${e.message}`);
    }
  }
  return { ...DEFAULT_SETTINGS };
}
function saveSettings(settings) {
  try { fm.writeString(paths.settings, JSON.stringify(settings)); }
  catch (e) { console.log(`‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫: ${e.message}`); }
}

// –î–∏–∞–ª–æ–≥
async function showAlert(title, message) {
  const alert = new Alert();
  alert.title = title;
  alert.message = message;
  alert.addAction("OK");
  await alert.presentAlert();
}

// –ü–æ–≤—Ç–æ—Ä—ã —Å –±—ç–∫–æ—Ñ—Ñ–æ–º
class NetworkError extends Error {
  constructor(message, retryable = true) { super(message); this.retryable = retryable; }
}
async function retryAsync(fn, maxRetries = CONFIG.maxRetries) {
  for (let i = 0; i < maxRetries; i++) {
    try { return await fn(); }
    catch (error) {
      console.log(`‚Üª –ü–æ–ø—ã—Ç–∫–∞ ${i + 1}/${maxRetries} –Ω–µ—É–¥–∞—á–Ω–∞: ${error.message}`);
      if (i === maxRetries - 1 || !error.retryable) throw error;
      await new Promise(resolve => Timer.schedule(1000 * (i + 1), false, resolve));
    }
  }
}

// –û–±—â–∏–π –∫—ç—à (–¥–ª—è –º–µ–ª–∫–∏—Ö —Å–ª–æ–≤–∞—Ä–µ–π)
class Cache {
  static isExpired(timestamp, minutes) {
    return (Date.now() - timestamp) / 60000 > minutes;
  }
  static read(path) {
    if (!fm.fileExists(path)) return null;
    try {
      const raw = JSON.parse(fm.readString(path));
      return this.isExpired(raw.timestamp, CONFIG.cacheMinutes) ? null : raw.data;
    } catch (e) {
      console.log(`‚ö†Ô∏è –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –∫—ç—à–∞: ${e.message}`);
      return null;
    }
  }
  static write(path, data) {
    try { fm.writeString(path, JSON.stringify({ data, timestamp: Date.now() })); }
    catch (e) { console.log(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ –∫—ç—à–∞: ${e.message}`); }
  }
}

// –õ–æ–∫–∞–ª—å–Ω—ã–π –∫—ç—à —Ü–µ–Ω —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –Ω–∞–±–æ—Ä–∞ ids (—á—Ç–æ–±—ã –∫—ç—à –ø–æ–¥—Ö–æ–¥–∏–ª –∫ –∑–∞–ø—Ä–æ—Å—É)
function readPricesCache(expectedIdsCSV) {
  if (!fm.fileExists(paths.cache)) return null;
  try {
    const raw = JSON.parse(fm.readString(paths.cache));
    if (Cache.isExpired(raw.timestamp, CONFIG.cacheMinutes)) return null;
    if (raw.ids !== expectedIdsCSV) return null;
    return raw.data || null;
  } catch (e) {
    console.log(`‚ö†Ô∏è –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –∫—ç—à–∞ —Ü–µ–Ω: ${e.message}`);
    return null;
  }
}
function writePricesCache(idsCSV, data) {
  try {
    fm.writeString(paths.cache, JSON.stringify({ data, timestamp: Date.now(), ids: idsCSV }));
  } catch (e) {
    console.log(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ –∫—ç—à–∞ —Ü–µ–Ω: ${e.message}`);
  }
}

// =====================
// API
// =====================

// –ò–∫–æ–Ω–∫–∞
async function getIcon(coin) {
  const file = fm.joinPath(paths.icons, `${coin.symbol}.png`);
  if (fm.fileExists(file)) {
    try { const img = Image.fromFile(file); if (img) return img; } catch { fm.remove(file); }
  }
  return await retryAsync(async () => {
    const req = new Request(coin.icon);
    req.timeoutInterval = CONFIG.timeout;
    const img = await req.loadImage();
    if (!img) throw new NetworkError("–ò–∫–æ–Ω–∫–∞ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞");
    try { fm.writeImage(file, img); } catch (e) { console.log(`‚ö†Ô∏è –ù–µ —Å–æ—Ö—Ä–∞–Ω–∏–ª –∏–∫–æ–Ω–∫—É ${coin.symbol}: ${e.message}`); }
    return img;
  });
}

// –ü–æ–∏—Å–∫ –º–æ–Ω–µ—Ç—ã –ø–æ —Å–∏–º–≤–æ–ª—É
async function searchCoin(symbol) {
  const cached = Cache.read(paths.search);
  if (cached && cached[symbol]) return cached[symbol];

  try {
    const url = `https://api.coingecko.com/api/v3/search?query=${encodeURIComponent(symbol)}`;
    const req = new Request(url);
    req.timeoutInterval = CONFIG.timeout;
    const data = await req.loadJSON();

    if (!data?.coins?.length) throw new NetworkError("–¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω");

    const results = data.coins.slice(0, 5).map(coin => ({
      id: coin.id,
      symbol: coin.symbol.toUpperCase(),
      name: coin.name,
      icon: coin.large || coin.thumb || coins[0].icon
    }));

    const newCache = { ...(cached || {}), [symbol]: results };   // ‚Üê –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å–ª–∏—è–Ω–∏–µ
    Cache.write(paths.search, newCache);
    return results;
  } catch (e) {
    console.log(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ —Ç–æ–∫–µ–Ω–∞ ${symbol}: ${e.message}`);
    return null;
  }
}

// –¶–µ–Ω—ã –¥–ª—è –Ω–∞–±–æ—Ä–∞ –º–æ–Ω–µ—Ç (—Å –∫—ç—à–µ–º –ø–æ ids)
async function fetchPrices(coinList = coins) {
  const ids = coinList.map(c => c.id).join(",");
  const cached = readPricesCache(ids);
  if (cached) return cached;

  return await retryAsync(async () => {
    const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd&include_24hr_change=true`;
    const req = new Request(url);
    req.timeoutInterval = CONFIG.timeout;
    const data = await req.loadJSON();
    if (!data || Object.keys(data).length === 0) throw new NetworkError("–ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç –æ—Ç API");
    writePricesCache(ids, data);
    return data;
  });
}

// =====================
// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
// =====================
function formatPrice(price) {
  if (!price || price === 0) return "‚Äî";
  if (price >= 1_000_000) return `${(price / 1_000_000).toFixed(1)}M$`;
  if (price >= 1_000)     return `${(price / 1_000).toFixed(1)}K$`;
  if (price >= 1)         return `${price.toFixed(2)}$`;
  if (price >= 0.01)      return `${price.toFixed(4)}$`;
  return `${price.toFixed(6).replace(/0+$/, "").replace(/\.$/, "")}$`;
}
function formatCurrency(value) {
  if (value >= 1_000_000) return `${(value / 1_000_000).toFixed(1)}M$`;
  if (value >= 1_000)     return `${(value / 1_000).toFixed(1)}K$`;
  return `${value.toFixed(2)}$`;
}

// =====================
// –ü–æ—Ä—Ç—Ñ–æ–ª–∏–æ
// =====================
class Portfolio {
  static load() {
    if (fm.fileExists(paths.portfolio)) {
      try { return JSON.parse(fm.readString(paths.portfolio)); }
      catch (e) { console.log(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ: ${e.message}`); }
    }
    return {};
  }
  static save(portfolio) {
    try { fm.writeString(paths.portfolio, JSON.stringify(portfolio)); }
    catch (e) { console.log(`‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ: ${e.message}`); }
  }
  static add(coinId, amount) {
    const p = this.load();
    p[coinId] = (p[coinId] || 0) + parseFloat(amount);
    this.save(p);
  }
  static remove(coinId) {
    const p = this.load();
    delete p[coinId];
    this.save(p);
  }
  static getValue(prices) {
    const portfolio = this.load();
    let totalValue = 0;
    const breakdown = [];

    for (const [coinId, amount] of Object.entries(portfolio)) {
      const info = prices[coinId];
      if (!info) continue;
      const price = info.usd || 0;
      const change = info.usd_24h_change || 0;
      const value = amount * price;
      totalValue += value;

      const coin = COINS_BY_ID.get(coinId) || coins.find(c => c.id === coinId);
      if (coin && value > 0) {
        breakdown.push({
          symbol: coin.symbol,
          amount,
          value,
          change,
          percentage: 0,
          coin
        });
      }
    }

    breakdown.forEach(item => {
      item.percentage = totalValue > 0 ? (item.value / totalValue) * 100 : 0;
    });

    return { totalValue, breakdown };
  }
}

// =====================
// –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
// =====================
class NotificationManager {
  static load() {
    if (fm.fileExists(paths.alerts)) {
      try { return JSON.parse(fm.readString(paths.alerts)); } catch {}
    }
    return { lastPrices: {}, lastPortfolioValue: 0, lastCheck: 0 };
  }
  static save(data) { fm.writeString(paths.alerts, JSON.stringify(data)); }

  static async checkAndNotify(prices, settings) {
    if (!settings.notifications.enabled) return;

    const state = this.load();
    const now = Date.now();
    if (now - state.lastCheck < 3600000) return; // –Ω–µ —á–∞—â–µ —á–∞—Å–∞

    const notifications = [];
    const allCoins = [...(settings.selectedCoins || []), ...(settings.extraCoins || [])];

    // –ò–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω
    for (const coin of allCoins) {
      const current = prices[coin.id]?.usd;
      const prev = state.lastPrices[coin.id];
      if (current && prev) {
        const change = ((current - prev) / prev) * 100;
        if (Math.abs(change) >= settings.notifications.priceChange) {
          notifications.push({
            title: `${coin.symbol} ${change > 0 ? 'üìà' : 'üìâ'}`,
            body: `–ò–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–∞ ${change.toFixed(1)}%: ${formatCurrency(current)}`
          });
        }
      }
      if (current) state.lastPrices[coin.id] = current;
    }

    // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –ø–æ—Ä—Ç—Ñ–µ–ª—è (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤—ã–±—Ä–∞–Ω —Ä–µ–∂–∏–º –ø–æ—Ä—Ç—Ñ–µ–ª—è —Å–ø—Ä–∞–≤–∞)
    if (settings.rightMode === 'portfolio') {
      const { totalValue } = Portfolio.getValue(prices);
      if (state.lastPortfolioValue > 0 && totalValue > 0) {
        const change = ((totalValue - state.lastPortfolioValue) / state.lastPortfolioValue) * 100;
        if (Math.abs(change) >= settings.notifications.portfolioChange) {
          notifications.push({
            title: `–ü–æ—Ä—Ç—Ñ–æ–ª–∏–æ ${change > 0 ? 'üí∞' : 'üìâ'}`,
            body: `–ò–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–∞ ${change.toFixed(1)}%: ${formatCurrency(totalValue)}`
          });
        }
      }
      state.lastPortfolioValue = totalValue;
    }

    // –û—Ç–ø—Ä–∞–≤–∫–∞
    notifications.forEach(n => {
      const notif = new Notification();
      notif.title = n.title;
      notif.body = n.body;
      notif.schedule();
    });

    state.lastCheck = now;
    this.save(state);
  }
}

// =====================
// –†–µ–Ω–¥–µ—Ä —Å—Ç—Ä–æ–∫–∏ (—É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è)
// =====================
async function renderItem(stack, data, settings) {
  const itemStack = stack.addStack();
  itemStack.layoutHorizontally();
  itemStack.spacing = 3;

  // –ò–∫–æ–Ω–∫–∞/–ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä
  if (data.type === 'portfolio-header') {
    const box = itemStack.addStack();
    box.size = new Size(CONFIG.icons.coin, CONFIG.icons.coin);
    box.cornerRadius = 2;
    box.centerAlignContent();
    const t = box.addText("üíº");
    t.font = Font.systemFont(14);
    t.centerAlignText();
  } else if (data.type === 'empty-portfolio') {
    const box = itemStack.addStack();
    box.size = new Size(CONFIG.icons.coin, CONFIG.icons.coin);
    box.cornerRadius = 2;
    box.centerAlignContent();
    const t = box.addText("üìä");
    t.font = Font.systemFont(14);
    t.centerAlignText();
  } else {
    try {
      const coinIcon = await getIcon(data.coin);
      const img = itemStack.addImage(coinIcon);
      img.imageSize = new Size(CONFIG.icons.coin, CONFIG.icons.coin);
      img.cornerRadius = 2;
    } catch {
      const fb = itemStack.addText("üí∞");
      fb.font = Font.systemFont(CONFIG.icons.coin - 2);
    }
  }

  // –¢–µ–∫—Å—Ç–æ–≤–æ–π –±–ª–æ–∫
  const textStack = itemStack.addStack();
  textStack.layoutVertically();
  textStack.spacing = 0;

  // –í–µ—Ä—Ö–Ω—è—è —Å—Ç—Ä–æ–∫–∞ (—Ç–∏–∫–µ—Ä/–∑–∞–≥–æ–ª–æ–≤–æ–∫)
  const titleText = textStack.addText(data.title);
  titleText.font = Font.systemFont(CONFIG.fonts.main.symbol);
  titleText.textColor = CONFIG.colors.text;

  // –ù–∏–∂–Ω—è—è —Å—Ç—Ä–æ–∫–∞ (–∑–Ω–∞—á–µ–Ω–∏–µ + –∏–∑–º–µ–Ω–µ–Ω–∏–µ)
  const bottom = textStack.addStack();
  bottom.layoutHorizontally();
  bottom.spacing = 2;

  const valueText = bottom.addText(data.value);
  valueText.font = Font.systemFont(CONFIG.fonts.main.price);
  valueText.textColor = data.valueColor || CONFIG.colors.subtext;

  if (data.change && settings.showChange) {
    const changeText = bottom.addText(data.change);
    changeText.font = Font.systemFont(CONFIG.fonts.main.change);
    changeText.textColor = data.changeColor || CONFIG.colors.subtext;
  }
}

// =====================
// –í–∏–¥–∂–µ—Ç
// =====================
async function createWidget() {
  const settings = loadSettings();
  const selectedCoins = settings.selectedCoins || coins.slice(0, 3);
  const extraCoins    = settings.extraCoins    || coins.slice(3, 6);

  const widget = new ListWidget();
  widget.setPadding(0, 2, 0, 2);
  widget.url = URLScheme.forRunningScript();

  try {
    // –°–±–æ—Ä –≤—Å–µ—Ö –Ω—É–∂–Ω—ã—Ö –º–æ–Ω–µ—Ç (–±–µ–∑ –¥—É–±–ª–µ–π)
    const portfolio = Portfolio.load();
    const portfolioCoins = Object.keys(portfolio).map(id => COINS_BY_ID.get(id) || coins.find(c => c.id === id)).filter(Boolean);
    const allCoins = [...selectedCoins, ...extraCoins, ...portfolioCoins];
    const uniqueCoins = allCoins.filter((c, i, arr) => arr.findIndex(x => x.id === c.id) === i);

    // –¶–µ–Ω—ã –∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    const prices = await fetchPrices(uniqueCoins.length ? uniqueCoins : coins);
    await NotificationManager.checkAndNotify(prices, settings);

    // –û—Å–Ω–æ–≤–Ω–æ–π —Ä—è–¥ (–ª–µ–≤–∞—è + –ø—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞)
    const mainStack = widget.addStack();
    mainStack.layoutHorizontally();

    // –õ–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞ ‚Äî –æ—Å–Ω–æ–≤–Ω—ã–µ –º–æ–Ω–µ—Ç—ã
    const leftStack = mainStack.addStack();
    leftStack.layoutVertically();
    leftStack.spacing = 1;

    for (const coin of selectedCoins) {
      const info = prices[coin.id];
      if (!info) continue;
      const price = info.usd ?? 0;
      const change = info.usd_24h_change ?? 0;
      const isPositive = change >= 0;
      await renderItem(leftStack, {
        type: 'coin',
        coin,
        title: coin.symbol,
        value: formatPrice(price),
        change: `${isPositive ? "‚ñ≤" : "‚ñº"}${Math.abs(change).toFixed(0)}%`,
        changeColor: isPositive ? CONFIG.colors.up : CONFIG.colors.down
      }, settings);
    }

    // –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –∫–æ–ª–æ–Ω–æ–∫
    mainStack.addSpacer();

    // –ü—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞ ‚Äî –¥–æ–ø. –º–æ–Ω–µ—Ç—ã –∏–ª–∏ –ø–æ—Ä—Ç—Ñ–µ–ª—å
    const rightStack = mainStack.addStack();
    rightStack.layoutVertically();
    rightStack.spacing = 1;

    if (settings.rightMode === 'portfolio') {
      // –ü–æ—Ä—Ç—Ñ–µ–ª—å
      const { totalValue, breakdown } = Portfolio.getValue(prices);

      if (breakdown.length > 0) {
        // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –ø–æ—Ä—Ç—Ñ–µ–ª—è
        await renderItem(rightStack, {
          type: 'portfolio-header',
          title: '–ü–æ—Ä—Ç—Ñ–µ–ª—å',
          value: formatCurrency(totalValue),
          valueColor: CONFIG.colors.portfolio
        }, settings);

        // –¢–æ–ø-–ø–æ–∑–∏—Ü–∏–∏
        const maxPositions = (selectedCoins.length >= 3) ? 2 : 3;
        const topPositions = breakdown.sort((a, b) => b.value - a.value).slice(0, maxPositions);

        for (const position of topPositions) {
          const isPositive = position.change >= 0;
          await renderItem(rightStack, {
            type: 'portfolio-coin',
            coin: position.coin,
            title: position.symbol,
            value: formatCurrency(position.value),
            valueColor: CONFIG.colors.portfolio,
            change: settings.showChange
              ? `${isPositive ? "‚ñ≤" : "‚ñº"}${Math.abs(position.change).toFixed(0)}%`
              : `${position.percentage.toFixed(0)}%`,
            changeColor: settings.showChange
              ? (isPositive ? CONFIG.colors.up : CONFIG.colors.down)
              : CONFIG.colors.subtext
          }, settings);
        }
      } else {
        // –ü—É—Å—Ç–æ–π –ø–æ—Ä—Ç—Ñ–µ–ª—å
        await renderItem(rightStack, {
          type: 'empty-portfolio',
          title: '–ü–æ—Ä—Ç—Ñ–µ–ª—å',
          value: '–ü—É—Å—Ç–æ',
          valueColor: CONFIG.colors.subtext
        }, settings);
      }
    } else {
      // –î–æ–ø. –º–æ–Ω–µ—Ç—ã
      for (const coin of extraCoins) {
        const info = prices[coin.id];
        if (!info) continue;
        const price = info.usd ?? 0;
        const change = info.usd_24h_change ?? 0;
        const isPositive = change >= 0;
        await renderItem(rightStack, {
          type: 'coin',
          coin,
          title: coin.symbol,
          value: formatPrice(price),
          change: `${isPositive ? "‚ñ≤" : "‚ñº"}${Math.abs(change).toFixed(0)}%`,
          changeColor: isPositive ? CONFIG.colors.up : CONFIG.colors.down
        }, settings);
      }
    }

  } catch (error) {
    // –ê–≤–∞—Ä–∏–π–Ω—ã–π —ç–∫—Ä–∞–Ω
    const errorStack = widget.addStack();
    errorStack.layoutVertically();
    errorStack.centerAlignContent();

    const errorIcon = errorStack.addText("‚ö†Ô∏è");
    errorIcon.font = Font.systemFont(CONFIG.icons.coin);

    const errorText = errorStack.addText("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏");
    errorText.textColor = CONFIG.colors.subtext;
    errorText.font = Font.systemFont(CONFIG.fonts.main.symbol);
    errorText.centerAlignText();

    console.log(`‚ùå –û—à–∏–±–∫–∞ –≤–∏–¥–∂–µ—Ç–∞: ${error.message}`);
  }

  return widget;
}

// =====================
// –ü–æ—Ä—Ç—Ñ–æ–ª–∏–æ ‚Äî UI
// =====================
async function addPortfolioPosition(coin) {
  const a = new Alert();
  a.title = `–î–æ–±–∞–≤–∏—Ç—å ${coin.symbol}`;
  a.message = "–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–æ–Ω–µ—Ç";
  a.addTextField("0.0", "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ");
  a.addAction("–î–æ–±–∞–≤–∏—Ç—å");
  a.addCancelAction("–û—Ç–º–µ–Ω–∞");

  if (await a.presentAlert() === 0) {
    const amount = parseFloat(a.textFieldValue(0));
    if (amount > 0) {
      Portfolio.add(coin.id, amount);
      await showAlert("–£—Å–ø–µ—Ö", `–î–æ–±–∞–≤–ª–µ–Ω–æ ${amount} ${coin.symbol}`);
    }
  }
}
async function addPortfolioBySymbol() {
  const a = new Alert();
  a.title = "–ù–∞–π—Ç–∏ —Ç–æ–∫–µ–Ω";
  a.message = "–í–≤–µ–¥–∏—Ç–µ —Å–∏–º–≤–æ–ª —Ç–æ–∫–µ–Ω–∞";
  a.addTextField("", "–°–∏–º–≤–æ–ª");
  a.addAction("–ù–∞–π—Ç–∏");
  a.addCancelAction("–û—Ç–º–µ–Ω–∞");

  if (await a.presentAlert() === 0) {
    const symbol = a.textFieldValue(0).trim().toUpperCase();
    if (!symbol) return;

    const results = await searchCoin(symbol);
    if (!results) { await showAlert("–û—à–∏–±–∫–∞", `–¢–æ–∫–µ–Ω ${symbol} –Ω–µ –Ω–∞–π–¥–µ–Ω`); return; }

    let selected = results[0];
    if (results.length > 1) {
      const menu = new Alert();
      menu.title = "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ–∫–µ–Ω";
      results.forEach(c => menu.addAction(`${c.symbol} - ${c.name}`));
      menu.addCancelAction("–û—Ç–º–µ–Ω–∞");
      const choice = await menu.presentSheet();
      if (choice >= 0 && choice < results.length) selected = results[choice]; else return;
    }

    if (!coins.some(c => c.id === selected.id)) {
      coins.push(selected);
      COINS_BY_ID.set(selected.id, selected);
    }
    await addPortfolioPosition(selected);
  }
}
async function showPortfolioMenu() {
  const portfolio = Portfolio.load();
  const menu = new Alert();
  menu.title = "üíº –ü–æ—Ä—Ç—Ñ–æ–ª–∏–æ";

  menu.addAction("–î–æ–±–∞–≤–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é");
  menu.addAction("–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –ø–æ–∑–∏—Ü–∏–∏");
  if (Object.keys(portfolio).length > 0) {
    menu.addAction("–£–¥–∞–ª–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é");
    menu.addDestructiveAction("–û—á–∏—Å—Ç–∏—Ç—å –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ");
  }
  menu.addCancelAction("–ù–∞–∑–∞–¥");

  const choice = await menu.presentSheet();

  switch (choice) {
    case 0: {
      const addMenu = new Alert();
      addMenu.title = "–î–æ–±–∞–≤–∏—Ç—å –≤ –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ";
      coins.forEach(c => addMenu.addAction(`${c.symbol} - ${c.id.replace(/-/g, ' ')}`));
      addMenu.addAction("–ù–∞–π—Ç–∏ —Ç–æ–∫–µ–Ω –ø–æ —Å–∏–º–≤–æ–ª—É");
      addMenu.addCancelAction("–û—Ç–º–µ–Ω–∞");

      const addChoice = await addMenu.presentSheet();
      if (addChoice >= 0 && addChoice < coins.length) {
        await addPortfolioPosition(coins[addChoice]);
      } else if (addChoice === coins.length) {
        await addPortfolioBySymbol();
      }
      break;
    }
    case 1: {
      const prices = await fetchPrices(coins);
      const { totalValue, breakdown } = Portfolio.getValue(prices);
      const a = new Alert();
      a.title = "üíº –ü–æ—Ä—Ç—Ñ–æ–ª–∏–æ";

      if (!breakdown.length) {
        a.message = "–ü–æ—Ä—Ç—Ñ–æ–ª–∏–æ –ø—É—Å—Ç–æ";
      } else {
        let msg = `üí∞ –û–±—â–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å: ${formatCurrency(totalValue)}\n\n`;
        breakdown.sort((a, b) => b.value - a.value).forEach(pos => {
          const icon = pos.change >= 0 ? "üìà" : "üìâ";
          msg += `${pos.symbol}: ${pos.amount.toFixed(4)}\n`;
          msg += `‚îî ${formatCurrency(pos.value)} (${pos.percentage.toFixed(1)}%) ${icon}${Math.abs(pos.change).toFixed(1)}%\n\n`;
        });
        a.message = msg;
      }
      a.addAction("OK");
      await a.presentAlert();
      break;
    }
    case 2: {
      const positions = Object.keys(portfolio);
      if (!positions.length) { await showAlert("–ü–æ—Ä—Ç—Ñ–æ–ª–∏–æ –ø—É—Å—Ç–æ", "–ù–µ—Ç –ø–æ–∑–∏—Ü–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è"); return; }

      const rm = new Alert();
      rm.title = "–£–¥–∞–ª–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é";
      positions.forEach(coinId => {
        const coin = COINS_BY_ID.get(coinId) || coins.find(c => c.id === coinId);
        const amount = portfolio[coinId];
        rm.addAction(`${coin?.symbol || coinId} - ${amount.toFixed(4)}`);
      });
      rm.addCancelAction("–û—Ç–º–µ–Ω–∞");

      const idx = await rm.presentSheet();
      if (idx >= 0 && idx < positions.length) {
        Portfolio.remove(positions[idx]);
        await showAlert("–£—Å–ø–µ—Ö", "–ü–æ–∑–∏—Ü–∏—è —É–¥–∞–ª–µ–Ω–∞");
      }
      break;
    }
    case 3: {
      const confirm = new Alert();
      confirm.title = "‚ö†Ô∏è –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ";
      confirm.message = "–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –ø–æ–∑–∏—Ü–∏–∏ –∏–∑ –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ?";
      confirm.addDestructiveAction("–£–¥–∞–ª–∏—Ç—å");
      confirm.addCancelAction("–û—Ç–º–µ–Ω–∞");
      if (await confirm.presentAlert() === 0) {
        fm.remove(paths.portfolio);
        await showAlert("–£—Å–ø–µ—Ö", "–ü–æ—Ä—Ç—Ñ–æ–ª–∏–æ –æ—á–∏—â–µ–Ω–æ");
      }
      break;
    }
  }
}

// =====================
// –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Äî UI
// =====================
async function showThresholdInput(key, title, settings) {
  const a = new Alert();
  a.title = title;
  a.addTextField(settings.notifications[key].toString(), "–ü—Ä–æ—Ü–µ–Ω—Ç");
  a.addAction("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å");
  a.addCancelAction("–û—Ç–º–µ–Ω–∞");

  if (await a.presentAlert() === 0) {
    const value = parseFloat(a.textFieldValue(0));
    if (value > 0 && value <= 100) {
      settings.notifications[key] = value;
      saveSettings(settings);
    }
  }
}
async function showCoinSelection(key, title) {
  const settings = loadSettings();
  const menu = new Alert();
  menu.title = title;

  coins.forEach(coin => {
    const isSelected = (settings[key] || []).some(c => c.id === coin.id);
    menu.addAction(`${isSelected ? "‚úì" : "‚óã"} ${coin.symbol}`);
  });
  menu.addCancelAction("–ì–æ—Ç–æ–≤–æ");

  const choice = await menu.presentSheet();
  if (choice >= 0 && choice < coins.length) {
    const selectedCoin = coins[choice];
    const current = settings[key] || [];

    const i = current.findIndex(c => c.id === selectedCoin.id);
    if (i >= 0) current.splice(i, 1);
    else if (current.length < 3) current.push(selectedCoin);

    settings[key] = current;
    saveSettings(settings);
    await showCoinSelection(key, title);
  }
}
function clearCache() {
  let count = 0;

  if (fm.fileExists(paths.icons)) {
    const files = fm.listContents(paths.icons);
    files.forEach(file => {
      try { fm.remove(fm.joinPath(paths.icons, file)); count++; } catch {}
    });
  }
  [paths.cache, paths.search].forEach(p => {
    if (fm.fileExists(p)) {
      try { fm.remove(p); count++; } catch {}
    }
  });

  console.log(`üóë –û—á–∏—â–µ–Ω–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫—ç—à–∞: ${count}`);
  return count;
}
async function showNotificationSettings() {
  const settings = loadSettings();
  const menu = new Alert();
  menu.title = "üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è";

  menu.addAction(settings.notifications.enabled ? "–û—Ç–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è" : "–í–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è");
  if (settings.notifications.enabled) {
    menu.addAction(`–ü–æ—Ä–æ–≥ —Ü–µ–Ω—ã: ${settings.notifications.priceChange}%`);
    menu.addAction(`–ü–æ—Ä–æ–≥ –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ: ${settings.notifications.portfolioChange}%`);
  }
  menu.addCancelAction("–ù–∞–∑–∞–¥");

  const choice = await menu.presentSheet();
  switch (choice) {
    case 0:
      settings.notifications.enabled = !settings.notifications.enabled;
      saveSettings(settings);
      break;
    case 1:
      await showThresholdInput('priceChange', '–ü–æ—Ä–æ–≥ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω—ã (%)', settings);
      break;
    case 2:
      await showThresholdInput('portfolioChange', '–ü–æ—Ä–æ–≥ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ (%)', settings);
      break;
  }
}
async function showSettingsMenu() {
  const settings = loadSettings();
  const menu = new Alert();
  menu.title = "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏";

  menu.addAction("–í—ã–±—Ä–∞—Ç—å –æ—Å–Ω–æ–≤–Ω—ã–µ –º–æ–Ω–µ—Ç—ã (–ª–µ–≤–æ)");
  menu.addAction("–í—ã–±—Ä–∞—Ç—å –¥–æ–ø –º–æ–Ω–µ—Ç—ã (–ø—Ä–∞–≤–æ)");
  menu.addAction(`–ü—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: ${settings.rightMode === 'portfolio' ? '–ü–æ—Ä—Ç—Ñ–æ–ª–∏–æ' : '–î–æ–ø –º–æ–Ω–µ—Ç—ã'}`);
  menu.addAction("–î–æ–±–∞–≤–∏—Ç—å —Ç–æ–∫–µ–Ω –ø–æ —Å–∏–º–≤–æ–ª—É");
  menu.addAction(settings.showChange ? "–°–∫—Ä—ã—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è" : "–ü–æ–∫–∞–∑–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è");
  menu.addAction("üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è");
  menu.addAction("–°–±—Ä–æ—Å–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏");
  menu.addCancelAction("–ù–∞–∑–∞–¥");

  const choice = await menu.presentSheet();
  switch (choice) {
    case 0: await showCoinSelection('selectedCoins', '–í—ã–±–µ—Ä–∏—Ç–µ –æ—Å–Ω–æ–≤–Ω—ã–µ –º–æ–Ω–µ—Ç—ã (–º–∞–∫—Å. 3)'); break;
    case 1: await showCoinSelection('extraCoins', '–í—ã–±–µ—Ä–∏—Ç–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–æ–Ω–µ—Ç—ã (–º–∞–∫—Å. 3)'); break;
    case 2:
      settings.rightMode = settings.rightMode === 'portfolio' ? 'extra' : 'portfolio';
      saveSettings(settings);
      break;
    case 3: await addPortfolioBySymbol(); break;
    case 4:
      settings.showChange = !settings.showChange;
      saveSettings(settings);
      break;
    case 5: await showNotificationSettings(); break;
    case 6:
      if (fm.fileExists(paths.settings)) {
        fm.remove(paths.settings);
        await showAlert("–£—Å–ø–µ—Ö", "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–±—Ä–æ—à–µ–Ω—ã");
      }
      break;
  }
}

// =====================
// –ì–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω ‚Äî UI
// =====================
async function showMainMenu() {
  const settings = loadSettings();
  const rightModeText = settings.rightMode === 'portfolio' ? '–ü–æ—Ä—Ç—Ñ–æ–ª–∏–æ' : '–î–æ–ø –º–æ–Ω–µ—Ç—ã';

  const menu = new Alert();
  menu.title = "‚ö° Crypto Widget Pro";
  menu.message = `–û—Å–Ω–æ–≤–Ω—ã–µ | ${rightModeText} | ${new Date().toLocaleTimeString()}`;

  menu.addAction("üîÑ –û–±–Ω–æ–≤–∏—Ç—å");
  menu.addAction("üìä –ü–æ–∫–∞–∑–∞—Ç—å –≤–∏–¥–∂–µ—Ç");
  menu.addAction("üíº –ü–æ—Ä—Ç—Ñ–æ–ª–∏–æ");
  menu.addAction("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏");
  menu.addDestructiveAction("üóë –û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à");
  menu.addCancelAction("–ó–∞–∫—Ä—ã—Ç—å");

  const choice = await menu.presentSheet();

  switch (choice) {
    case 0: {
      clearCache();
      const widget = await createWidget();
      await widget.presentSmall();
      break;
    }
    case 1: {
      const widget = await createWidget();
      await widget.presentSmall();
      break;
    }
    case 2: await showPortfolioMenu(); break;
    case 3: await showSettingsMenu(); break;
    case 4: {
      const deleted = clearCache();
      await showAlert("–û—á–∏—Å—Ç–∫–∞ –∫—ç—à–∞", deleted > 0 ? `‚úÖ –£–¥–∞–ª–µ–Ω–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: ${deleted}` : "‚ÑπÔ∏è –ö—ç—à —É–∂–µ –ø—É—Å—Ç");
      break;
    }
  }
}

// =====================
// –ó–∞–ø—É—Å–∫
// =====================
async function main() {
  if (config.runsInApp) {
    await showMainMenu();
  } else {
    const widget = await createWidget();
    Script.setWidget(widget);
  }
  Script.complete();
}
await main();